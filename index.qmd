---
title: "NBHF Clusters: Streamlined Results"
author: Jackson Vanfleet-Brown
date: 02/25/2024
editor: source
---

## Intro {.unnumbered}

We want to identify clusters within our training set before we make our classifier learn from it. There are two objectives for unsupervised clustering:

1. Look across species to identify whether species classes form separate clusters (@sec-species).
    - The existence of clusters suggests that there are meaningful differences between classes that the classifier can be trained to recognize.
2. Look within species classes to assess variability among events (@sec-events).
    -  The existence of clusters within an individual species class may indicate that there are outlying events with anomalous features that should be excluded from the training set.

```{r}
#| output: false

library(identidrift) # package with training data. On GitHub, "jackvfb/identidrift"
library(tidyverse)
library(vegan)
library(densityClust)
```
## Objective 1 {#sec-species}

### Method

```{r}
#| output: false
#| echo: true

set.seed(123)

samp <- nbhf_clicks %>% 
  group_by(species) %>% # <1>
  slice_sample(n=200) %>% # <1>
  ungroup()

samp_rm <- samp %>% 
  select(-c(UID:noiseLevel, BinaryFile, eventLabel, # <2>
            detectorName, db)) %>% # <2>
  select(species, eventId, duration:peak, # <3>
         Q_10dB:centerkHz_3dB) # <3>

dist <- samp_rm %>%
  select(-c(species, eventId)) %>%
  mutate(id = 1:n()) %>%
  column_to_rownames("id") %>%
  scale() %>%
  dist(method="euclidean") # <4>

cl <- densityClust(dist)
cl <- findClusters(cl, rho=25, delta=2) # <5>
```
1. Select 200 clicks at random from each species to reduce computational burden
2. Drop metadata
3. Drop variables such as `peaktopeak2`, `trough`, and others to avoid creating artifacts in the cluster plot.
4. Calculate Euclidean distances
5. Select value of $\delta$ and $\rho$. This affects how many clusters into which the data will be partitioned.

Using the above method, the density clustering algorithm formed the clusters shown in @fig-density-clust. The counts of each species in each of the resulting clusters is given in @tbl-clust-assn. The MDS plot is shown with the points colored by species in @fig-mds-species.

```{r}
#| label: fig-density-clust
#| fig-cap: "Density clusters with Four clusters formed with \u03c1=25 and \u03B4=2"

plotDensityClust(cl)
```

```{r}
#| label: tbl-clust-assn
#| tbl-cap: "Table of cluster assignments"

table(samp_rm$species, cl$clusters)
```

```{r}
#| label: fig-mds-species
#| warning: false
#| fig-cap: "MDS plot showing distances between clicks in the training set, colored by species"

mds <- as_tibble(cmdscale(dist))
mds <- cbind(mds, "species" = samp_rm$species)

ggplot(data = mds) +
  geom_point(aes(V1, V2, color = species)) +
  xlab("Dimension 1") +
  ylab("Dimension 2")
```


### Discussion

- For all species, we see that clicks cluster predominately in a single cluster, with little overlap between different species classes.
- The MDS plot similarly shows that clicks separate from one another on the basis of species class.
- From @tbl-clust-assn we see that cluster 3 is very small, containing just three Kogia clicks.
    - @tbl-clust-ks shows that the entirety of cluster 3 is formed from a few anomalous clicks in *Kogia* event identified as `PG2_02_09_CCES_023_Ksp - Copy.OE4`.
    - That same event, which happens to be the largest *Kogia* event in the entire training set, has the overwhelming majority of it's clicks in cluster 4.

```{r}
#| label: tbl-clust-ks
#| tbl-cap: "Table of cluster assignments for all *Kogia* events"
#| 
df <- data.frame("species" = samp_rm$species,
           "eventId" = samp_rm$eventId,
           "cluster" = cl$clusters) %>%
  filter(species=="ks")

table(df$eventId, df$cluster)
```

## Objective 2 {#sec-events}

We will now subset the training data by species and then re perform density clustering to identify anomalous events.

### Method

```{r}
#| echo: true
#| output: false

set.seed(123)

samp2 <- nbhf_clicks %>%
  nest(data=-species) %>%
  mutate(median_ev_n=map_dbl(data,\(d) d %>% count(eventId) %>% pull(n) %>% median())) %>% # <1>
  mutate(samp=map2(data, median_ev_n, \(d, s) d %>% group_by(eventId) %>% slice_sample(n=s) %>% ungroup())) %>% # <2>
  mutate(samp=map(samp, \(s) select(s, eventId, duration:peak, Q_10dB:centerkHz_3dB))) %>% # <3>
  mutate(samp=map(samp, \(s) s %>% mutate(id=1:n()) %>% drop_na())) %>%
  select(species, samp) %>% 
  unnest(samp)


sp <- c("ks", "pd", "pp")
clicks <- lapply(sp, \(x) filter(samp2, species==x)) # <4>
dist2 <- lapply(clicks, \(c) c %>% select(-c(species, eventId)) %>% column_to_rownames("id") %>% scale() %>% dist()) # <5>
cl2 <- lapply(dist2, densityClust) #<6>
cl2 <- lapply(cl2, findClusters, delta = 8, rho = 5) #<6>
```

1. Determine the median event $n$ for each species
2. For events with $n$ greater than the median, slice a sample in size equal to the median. Since event sizes could vary across several orders of magnitude, this was thought to help reduce over representation of certain events in the cluster plots.
3. Select variables of interest, same as in @sec-species.
4. Subset data by species class
5. Create distance matrices.
6. Perform density clustering. Static values chosen for $\rho$ and $\delta$. This decision does not seem to be critical, because the algorithm strongly favors a single cluster for each species.

@fig-event-clusters shows the resulting density cluster plots and @fig-mds-events shows the plots with the points colored by event.

```{r}
#| label: fig-event-clusters
#| fig-cap: "Click clusters for each species class"
#| fig-subcap:
#|     - "*Kogia*"
#|     - "Dall's porpoise"
#|     - "Harbor porpoise"

plotDensityClust(cl2[[1]])
plotDensityClust(cl2[[2]])
plotDensityClust(cl2[[3]])
```

```{r}
#| label: fig-mds-events
#| fig-cap: "MDS plot showing distances between clicks, colored by event. Legend is hidden due to large number of events in each species class."
#| fig-subcap:
#|     - "*Kogia*"
#|     - "Dall's porpoise"
#|     - "Harbor porpoise"
#| 

mds2 <- lapply(dist2, function(x) {as_tibble(cmdscale(x))})
mds2 <- map2(mds2, clicks, function(x, y) {cbind(x, "eventId" = y$eventId)})

makePlot <- function(x) {
  ggplot(data = x) +
    geom_point(aes(V1, V2, color = eventId), show.legend = FALSE) +
    xlab("Dimension 1") +
    ylab("Dimension 2")
}

makePlot(mds2[[1]])
makePlot(mds2[[2]])
makePlot(mds2[[3]])
```

### Discussion

- The density clustering algorithm appears to strongly favors a single cluster in each species, suggesting that there are no outlying events.
- When points are colored by event, variation among events is more evident. This variation does not appear to be strong enough to manifest as more than one density-based cluster.